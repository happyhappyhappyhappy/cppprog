# ABC098A_累積和

[Problem](https://atcoder.jp/contests/abc098/tasks/arc098_a)

---
## 1回目
# 2019/09/22

* 今回は解説の通りにした方が良い解答ができそうなので、そちらを使う。

* しかし、累積和の仕組みがよく分からないので自分でEの累積和を出して、次にWの累積和を出して、照合するとする。

* 尚Drken氏の解答は[これ](https://atcoder.jp/contests/arc098/submissions/2586417)と[これ](https://atcoder.jp/contests/arc098/submissions/2565352)

* 累積和の参考ページをさがす。
    * [1](https://qiita.com/drken/items/56a6b68edef8fc605821)←Drken氏 一択。これを見るとARC090Aも分かってくるので3回目はこれを試す。

* 一応,E,Wの値を足したところで今日は終わり。

# 2019/09/23

* サンプル1のE,WとEの累積和,Wの累積和と解答を見比べてみて、リーダーより左側がWの累積和、右側がEの累積和を見ていく内に定式化出来たみたいだ。

* 一応出力デバッグして、実行したところ完了。

* subtask_1_12.txtが実行時間19ms,メモリ6512kbと結構使う。サンプルは簡単な物だけだったみたいだ。

* 一応これでコミットして終了。

---
## 2回目

* ソースを引用するmarkdownの書き方の研究

# 2019/09/25

* 文字列→右と左のフラグを0,1にした配列を作成→テスト
    * 一瞬true,falseにした方が良かった気がしたがそれをすると単純計算で累積和が出来ないのでパス。
* 配列をさらに累積和にする

## 2回目完了

* [解答](https://atcoder.jp/contests/abc098/submissions/7703585)

* 外出しにするとメモリも実行時間増えるな。vector変数が無用に増えるからか
    * メモリを使っていない例あるかな[解答](https://atcoder.jp/contests/abc098/submissions?f.Task=arc098_a&f.Language=3003&f.Status=AC&f.User=)より検索。

---
## 3回目

# 2019/09/29

* 今回は`long int > loi`をしない、ベクトル変数を`vecter[]`の取り出し方でやってみる。
* 最初からベクトルの長さ宣言してしまえ。

* メンバー文字列→0,1変換かけたところで終了。

# 2019/10/01

* 累積和を作成

* 次の言語はrubyにしようと考える

# 2019/10/03

* 図を手書きで書いてみて位置関係を確認。

* max関数でどっちが大きいか確認→algorithmライブラリをインポート
    * どっちが小さいかなのでminだった

* 実行完了
    * 実行時間が18ms,メモリが5764 KBだったので、前と同じ手法なのになぜ変わるかと思ったらsolverの中の配列がint型だった。long intに差し替えて実行し直したら2倍で2回目よりは少なかった。define定義はそれなりの時間食うのか。これがプリコンパイルというものか。
    